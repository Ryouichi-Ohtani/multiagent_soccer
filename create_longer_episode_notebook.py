#!/usr/bin/env python3
"""
Create notebook with 20-second episodes
"""

import json

def create_longer_episode_cells():
    """Create cells for 20-second episodes"""
    
    cells = []
    
    # Header
    cells.append({
        "cell_type": "markdown",
        "metadata": {"id": "longer_episode_header"},
        "source": [
            "# ⏱️ Extended Episode Duration (20 seconds)\n",
            "## エピソードを20秒に拡張した本格的なサッカーゲーム\n\n",
            "より現実的なサッカーゲームのために、1エピソードを20秒（約600ステップ @ 30FPS）に設定します。"
        ]
    })
    
    # Updated configuration
    cells.append({
        "cell_type": "markdown",
        "metadata": {"id": "updated_config_header"},
        "source": ["### ⚙️ 拡張エピソード設定"]
    })
    
    cells.append({
        "cell_type": "code",
        "metadata": {"id": "extended_config"},
        "execution_count": None,
        "outputs": [],
        "source": [
            "# Extended episode configuration\n",
            "@dataclass\n",
            "class ExtendedSoccerConfig(SoccerEnvironmentConfig):\n",
            "    \"\"\"Extended configuration for 20-second episodes\"\"\"\n",
            "    # Override MAX_STEPS for 20 seconds at ~30 FPS\n",
            "    MAX_STEPS: int = 600  # 20 seconds * 30 steps/second\n",
            "    \n",
            "    # Adjust speeds for longer gameplay\n",
            "    PLAYER_SPEED: float = 4.0  # Slightly slower for more strategic play\n",
            "    BALL_SPEED_MULTIPLIER: float = 1.3  # Slightly slower ball\n",
            "    \n",
            "    # Enhanced physics for longer games\n",
            "    FRICTION: float = 0.93  # Less friction for smoother movement\n",
            "    BALL_DECAY: float = 0.97  # Ball moves longer\n",
            "    \n",
            "    # Goal celebration pause (optional)\n",
            "    GOAL_PAUSE_STEPS: int = 30  # 1 second pause after goal\n",
            "\n",
            "print(\"✅ Extended configuration created:\")\n",
            "print(f\"   Episode duration: 20 seconds (600 steps)\")\n",
            "print(f\"   Approx FPS: 30\")\n",
            "print(f\"   Player speed: 4.0\")\n",
            "print(f\"   Ball speed multiplier: 1.3\")"
        ]
    })
    
    # Enhanced Expert Agent for longer episodes
    cells.append({
        "cell_type": "markdown",
        "metadata": {"id": "enhanced_expert_header"},
        "source": ["### 🎯 改良版エキスパートエージェント（20秒対応）"]
    })
    
    cells.append({
        "cell_type": "code",
        "metadata": {"id": "enhanced_expert_agent"},
        "execution_count": None,
        "outputs": [],
        "source": [
            "class EnhancedExpertAgent(BaseAgent):\n",
            "    \"\"\"Enhanced expert agent for 20-second episodes with stamina management\"\"\"\n",
            "    \n",
            "    def __init__(self, agent_id: int, team: int, config: ExtendedSoccerConfig):\n",
            "        super().__init__(agent_id, 5)\n",
            "        self.team = team\n",
            "        self.config = config\n",
            "        self.field_width, self.field_height = config.FIELD_SIZE\n",
            "        self.stamina = 1.0  # Stamina system for longer games\n",
            "        self.role = 'attacker' if agent_id % 2 == 0 else 'defender'\n",
            "        \n",
            "    def select_action(self, observation: np.ndarray, training: bool = True) -> np.ndarray:\n",
            "        \"\"\"Enhanced strategy for longer episodes\"\"\"\n",
            "        # Parse observation\n",
            "        self_pos = observation[0:2]\n",
            "        ball_pos = observation[4:6]\n",
            "        teammate_pos = observation[8:10]\n",
            "        opp1_pos = observation[12:14]\n",
            "        opp2_pos = observation[16:18]\n",
            "        \n",
            "        # Denormalize positions\n",
            "        self_x, self_y = self_pos[0] * self.field_width, self_pos[1] * self.field_height\n",
            "        ball_x, ball_y = ball_pos[0] * self.field_width, ball_pos[1] * self.field_height\n",
            "        teammate_x, teammate_y = teammate_pos[0] * self.field_width, teammate_pos[1] * self.field_height\n",
            "        \n",
            "        # Calculate distances\n",
            "        dist_to_ball = np.sqrt((self_x - ball_x)**2 + (self_y - ball_y)**2)\n",
            "        dist_to_teammate = np.sqrt((self_x - teammate_x)**2 + (self_y - teammate_y)**2)\n",
            "        \n",
            "        # Goal positions\n",
            "        if self.team == 0:  # Blue team\n",
            "            own_goal_x, enemy_goal_x = 0, self.field_width\n",
            "        else:  # Red team\n",
            "            own_goal_x, enemy_goal_x = self.field_width, 0\n",
            "        goal_y = self.field_height / 2\n",
            "        \n",
            "        # Role-based strategy\n",
            "        if self.role == 'attacker':\n",
            "            # Attackers focus on scoring\n",
            "            if dist_to_ball > 60:\n",
            "                # Rush to ball\n",
            "                move_x = np.clip((ball_x - self_x) / 80, -1, 1)\n",
            "                move_y = np.clip((ball_y - self_y) / 80, -1, 1)\n",
            "                kick_power = 0.0\n",
            "                kick_dir_x, kick_dir_y = 0.0, 0.0\n",
            "            else:\n",
            "                # Dribble towards goal or shoot\n",
            "                move_x = np.clip((ball_x - self_x) / 40, -1, 1)\n",
            "                move_y = np.clip((ball_y - self_y) / 40, -1, 1)\n",
            "                \n",
            "                # Calculate shot angle\n",
            "                goal_dist = np.sqrt((enemy_goal_x - ball_x)**2 + (goal_y - ball_y)**2)\n",
            "                \n",
            "                if goal_dist < 200:  # Close enough to shoot\n",
            "                    kick_power = 0.9\n",
            "                    kick_dir_x = np.clip((enemy_goal_x - ball_x) / self.field_width, -1, 1)\n",
            "                    kick_dir_y = np.clip((goal_y - ball_y) / self.field_height, -1, 1)\n",
            "                else:\n",
            "                    # Dribble forward\n",
            "                    kick_power = 0.3\n",
            "                    kick_dir_x = np.clip((enemy_goal_x - ball_x) / self.field_width * 0.5, -1, 1)\n",
            "                    kick_dir_y = 0.0\n",
            "        \n",
            "        else:  # Defender\n",
            "            # Defenders focus on ball interception and clearing\n",
            "            ball_to_own_goal = np.sqrt((own_goal_x - ball_x)**2 + (goal_y - ball_y)**2)\n",
            "            \n",
            "            if ball_to_own_goal < 200:  # Ball near own goal - defend!\n",
            "                # Rush to ball\n",
            "                move_x = np.clip((ball_x - self_x) / 50, -1, 1)\n",
            "                move_y = np.clip((ball_y - self_y) / 50, -1, 1)\n",
            "                \n",
            "                if dist_to_ball < 40:\n",
            "                    # Clear ball away from goal\n",
            "                    kick_power = 0.8\n",
            "                    kick_dir_x = np.sign(enemy_goal_x - own_goal_x)\n",
            "                    kick_dir_y = np.random.uniform(-0.3, 0.3)  # Random clear direction\n",
            "                else:\n",
            "                    kick_power = 0.0\n",
            "                    kick_dir_x, kick_dir_y = 0.0, 0.0\n",
            "            \n",
            "            elif dist_to_ball < 100:\n",
            "                # Support play\n",
            "                move_x = np.clip((ball_x - self_x) / 80, -1, 1)\n",
            "                move_y = np.clip((ball_y - self_y) / 80, -1, 1)\n",
            "                \n",
            "                if dist_to_ball < 40:\n",
            "                    # Pass to teammate\n",
            "                    kick_power = 0.5\n",
            "                    kick_dir_x = np.clip((teammate_x - ball_x) / self.field_width, -1, 1)\n",
            "                    kick_dir_y = np.clip((teammate_y - ball_y) / self.field_height, -1, 1)\n",
            "                else:\n",
            "                    kick_power = 0.0\n",
            "                    kick_dir_x, kick_dir_y = 0.0, 0.0\n",
            "            \n",
            "            else:\n",
            "                # Position between ball and own goal\n",
            "                defensive_x = (ball_x + own_goal_x) / 2\n",
            "                defensive_y = (ball_y + goal_y) / 2\n",
            "                move_x = np.clip((defensive_x - self_x) / 100, -1, 1)\n",
            "                move_y = np.clip((defensive_y - self_y) / 100, -1, 1)\n",
            "                kick_power = 0.0\n",
            "                kick_dir_x, kick_dir_y = 0.0, 0.0\n",
            "        \n",
            "        # Stamina management for 20-second games\n",
            "        self.stamina = max(0.3, self.stamina - 0.001)  # Gradual stamina decrease\n",
            "        speed_modifier = 0.7 + 0.3 * self.stamina  # Speed affected by stamina\n",
            "        \n",
            "        move_x *= speed_modifier\n",
            "        move_y *= speed_modifier\n",
            "        \n",
            "        action = np.array([move_x, move_y, kick_power, kick_dir_x, kick_dir_y], dtype=np.float32)\n",
            "        return np.clip(action, [-1, -1, 0, -1, -1], [1, 1, 1, 1, 1])\n",
            "    \n",
            "    def reset_stamina(self):\n",
            "        \"\"\"Reset stamina for new episode\"\"\"\n",
            "        self.stamina = 1.0\n",
            "    \n",
            "    def learn(self, experiences: List) -> Dict[str, float]:\n",
            "        return {\"loss\": 0.0}\n",
            "\n",
            "print(\"✅ Enhanced expert agent implemented with:\")\n",
            "print(\"   - Role-based strategies (attacker/defender)\")\n",
            "print(\"   - Stamina management for 20-second games\")\n",
            "print(\"   - Advanced positioning and passing\")"
        ]
    })
    
    # Extended training with longer episodes
    cells.append({
        "cell_type": "markdown",
        "metadata": {"id": "extended_training_header"},
        "source": ["### 🎮 20秒エピソードでの訓練"]
    })
    
    cells.append({
        "cell_type": "code",
        "metadata": {"id": "extended_episode_training"},
        "execution_count": None,
        "outputs": [],
        "source": [
            "class LongEpisodeTrainer:\n",
            "    \"\"\"Trainer for 20-second episodes\"\"\"\n",
            "    \n",
            "    def __init__(self, config: ExtendedSoccerConfig):\n",
            "        self.config = config\n",
            "        self.episode_stats = []\n",
            "        \n",
            "    def run_episode(self, agents_dict, record_video=False, verbose=True):\n",
            "        \"\"\"Run a single 20-second episode\"\"\"\n",
            "        render_mode = \"rgb_array\" if record_video else None\n",
            "        env = make_soccer_env(self.config, render_mode=render_mode, action_type=\"continuous\")\n",
            "        \n",
            "        env.reset()\n",
            "        \n",
            "        # Episode statistics\n",
            "        stats = {\n",
            "            'scores': [0, 0],\n",
            "            'rewards': {agent: 0 for agent in env.agents},\n",
            "            'steps': 0,\n",
            "            'goals_timeline': [],  # When goals were scored\n",
            "            'possession_time': {0: 0, 1: 0, -1: 0},  # Ball possession time\n",
            "            'shots': {0: 0, 1: 0},  # Shot attempts\n",
            "        }\n",
            "        \n",
            "        video_frames = [] if record_video else None\n",
            "        last_ball_possession = -1\n",
            "        \n",
            "        # Run 20-second episode\n",
            "        for step in range(self.config.MAX_STEPS):\n",
            "            # Record frame\n",
            "            if record_video and step % 2 == 0:  # Record every 2nd frame to reduce size\n",
            "                frame = env.render()\n",
            "                if frame is not None:\n",
            "                    video_frames.append(frame)\n",
            "            \n",
            "            # Get actions from all agents\n",
            "            for agent_name in env.agents:\n",
            "                if not env.terminations.get(agent_name, False) and not env.truncations.get(agent_name, False):\n",
            "                    obs = env.observe(agent_name)\n",
            "                    action = agents_dict[agent_name].select_action(obs, training=False)\n",
            "                    \n",
            "                    # Detect shots (high kick power)\n",
            "                    if action[2] > 0.7:  # kick_power > 0.7\n",
            "                        team = int(agent_name.split('_')[1]) // 2\n",
            "                        stats['shots'][team] += 1\n",
            "                    \n",
            "                    env.step(action)\n",
            "                    stats['rewards'][agent_name] += env.rewards.get(agent_name, 0)\n",
            "                    \n",
            "                    if env.terminations.get(agent_name, False) or env.truncations.get(agent_name, False):\n",
            "                        break\n",
            "            \n",
            "            # Track goals\n",
            "            if env.scores[0] > stats['scores'][0]:\n",
            "                stats['goals_timeline'].append({'team': 0, 'time': step / 30})  # Convert to seconds\n",
            "                stats['scores'][0] = env.scores[0]\n",
            "                if verbose:\n",
            "                    print(f\"⚽ GOAL! Team 0 scores at {step/30:.1f}s\")\n",
            "            \n",
            "            if env.scores[1] > stats['scores'][1]:\n",
            "                stats['goals_timeline'].append({'team': 1, 'time': step / 30})\n",
            "                stats['scores'][1] = env.scores[1]\n",
            "                if verbose:\n",
            "                    print(f\"⚽ GOAL! Team 1 scores at {step/30:.1f}s\")\n",
            "            \n",
            "            # Track possession (simplified)\n",
            "            current_possession = getattr(env, 'ball_possession', -1)\n",
            "            if current_possession != -1:\n",
            "                team = current_possession // 2\n",
            "                stats['possession_time'][team] += 1\n",
            "            else:\n",
            "                stats['possession_time'][-1] += 1\n",
            "            \n",
            "            stats['steps'] += 1\n",
            "        \n",
            "        env.close()\n",
            "        \n",
            "        # Calculate possession percentage\n",
            "        total_possession = sum(stats['possession_time'].values())\n",
            "        if total_possession > 0:\n",
            "            stats['possession_pct'] = {\n",
            "                0: stats['possession_time'][0] / total_possession * 100,\n",
            "                1: stats['possession_time'][1] / total_possession * 100\n",
            "            }\n",
            "        else:\n",
            "            stats['possession_pct'] = {0: 0, 1: 0}\n",
            "        \n",
            "        return stats, video_frames\n",
            "    \n",
            "    def run_match(self, agents_dict, num_episodes=5, record_first=True):\n",
            "        \"\"\"Run multiple 20-second matches\"\"\"\n",
            "        print(f\"🏆 Running {num_episodes} x 20-second matches\")\n",
            "        print(\"=\" * 60)\n",
            "        \n",
            "        all_stats = []\n",
            "        videos = []\n",
            "        \n",
            "        for episode in range(num_episodes):\n",
            "            print(f\"\\n📅 Match {episode + 1}/{num_episodes}\")\n",
            "            record = record_first and episode == 0\n",
            "            \n",
            "            stats, frames = self.run_episode(agents_dict, record_video=record, verbose=True)\n",
            "            all_stats.append(stats)\n",
            "            \n",
            "            if frames:\n",
            "                videos.append(frames)\n",
            "            \n",
            "            # Match summary\n",
            "            print(f\"\\n📊 Match {episode + 1} Summary:\")\n",
            "            print(f\"   Final Score: {stats['scores'][0]} - {stats['scores'][1]}\")\n",
            "            print(f\"   Total Rewards: {sum(stats['rewards'].values()):.1f}\")\n",
            "            print(f\"   Shots: Team 0 = {stats['shots'][0]}, Team 1 = {stats['shots'][1]}\")\n",
            "            print(f\"   Possession: Team 0 = {stats['possession_pct'][0]:.1f}%, Team 1 = {stats['possession_pct'][1]:.1f}%\")\n",
            "            print(f\"   Goals scored at: {[f\"{g['time']:.1f}s\" for g in stats['goals_timeline']]}\")\n",
            "        \n",
            "        return all_stats, videos\n",
            "\n",
            "print(\"✅ Long episode trainer ready!\")\n",
            "print(\"   - 20-second episodes (600 steps)\")\n",
            "print(\"   - Detailed statistics tracking\")\n",
            "print(\"   - Goal timeline and possession stats\")"
        ]
    })
    
    # Run 20-second matches
    cells.append({
        "cell_type": "markdown",
        "metadata": {"id": "run_matches_header"},
        "source": ["### 🏆 20秒マッチの実行"]
    })
    
    cells.append({
        "cell_type": "code",
        "metadata": {"id": "run_20sec_matches"},
        "execution_count": None,
        "outputs": [],
        "source": [
            "# Create enhanced expert agents for 20-second games\n",
            "print(\"🎯 Creating enhanced expert agents for 20-second matches...\")\n",
            "\n",
            "extended_config = ExtendedSoccerConfig()\n",
            "enhanced_experts = {}\n",
            "\n",
            "for i in range(4):\n",
            "    agent_name = f\"player_{i}\"\n",
            "    team = i // 2\n",
            "    enhanced_experts[agent_name] = EnhancedExpertAgent(i, team, extended_config)\n",
            "\n",
            "print(\"✅ Enhanced expert agents created\")\n",
            "print(\"   Team 0: player_0 (attacker), player_1 (defender)\")\n",
            "print(\"   Team 1: player_2 (attacker), player_3 (defender)\")\n",
            "\n",
            "# Run matches\n",
            "print(\"\\n\" + \"=\" * 60)\n",
            "trainer = LongEpisodeTrainer(extended_config)\n",
            "match_stats, match_videos = trainer.run_match(\n",
            "    enhanced_experts,\n",
            "    num_episodes=3,  # Run 3 matches\n",
            "    record_first=True  # Record first match\n",
            ")\n",
            "\n",
            "# Overall statistics\n",
            "print(\"\\n\" + \"=\" * 60)\n",
            "print(\"🏅 Overall Statistics (3 matches):\")\n",
            "total_goals_0 = sum(s['scores'][0] for s in match_stats)\n",
            "total_goals_1 = sum(s['scores'][1] for s in match_stats)\n",
            "avg_rewards = np.mean([sum(s['rewards'].values()) for s in match_stats])\n",
            "avg_shots_0 = np.mean([s['shots'][0] for s in match_stats])\n",
            "avg_shots_1 = np.mean([s['shots'][1] for s in match_stats])\n",
            "\n",
            "print(f\"   Total Goals: Team 0 = {total_goals_0}, Team 1 = {total_goals_1}\")\n",
            "print(f\"   Average Rewards per Match: {avg_rewards:.1f}\")\n",
            "print(f\"   Average Shots per Match: Team 0 = {avg_shots_0:.1f}, Team 1 = {avg_shots_1:.1f}\")\n",
            "print(f\"   Goals per 20 seconds: {(total_goals_0 + total_goals_1) / 3:.2f}\")"
        ]
    })
    
    # Visualize 20-second match
    cells.append({
        "cell_type": "markdown",
        "metadata": {"id": "visualize_match_header"},
        "source": ["### 📊 20秒マッチの可視化"]
    })
    
    cells.append({
        "cell_type": "code",
        "metadata": {"id": "visualize_20sec_match"},
        "execution_count": None,
        "outputs": [],
        "source": [
            "# Visualize match statistics\n",
            "if match_stats:\n",
            "    fig, axes = plt.subplots(2, 2, figsize=(15, 10))\n",
            "    \n",
            "    # Goals over matches\n",
            "    ax = axes[0, 0]\n",
            "    matches = range(1, len(match_stats) + 1)\n",
            "    team0_scores = [s['scores'][0] for s in match_stats]\n",
            "    team1_scores = [s['scores'][1] for s in match_stats]\n",
            "    \n",
            "    width = 0.35\n",
            "    x = np.arange(len(matches))\n",
            "    ax.bar(x - width/2, team0_scores, width, label='Team 0 (Blue)', color='blue', alpha=0.7)\n",
            "    ax.bar(x + width/2, team1_scores, width, label='Team 1 (Red)', color='red', alpha=0.7)\n",
            "    ax.set_xlabel('Match Number')\n",
            "    ax.set_ylabel('Goals Scored')\n",
            "    ax.set_title('Goals per 20-second Match')\n",
            "    ax.set_xticks(x)\n",
            "    ax.set_xticklabels(matches)\n",
            "    ax.legend()\n",
            "    ax.grid(True, alpha=0.3, axis='y')\n",
            "    \n",
            "    # Shots comparison\n",
            "    ax = axes[0, 1]\n",
            "    team0_shots = [s['shots'][0] for s in match_stats]\n",
            "    team1_shots = [s['shots'][1] for s in match_stats]\n",
            "    \n",
            "    ax.plot(matches, team0_shots, 'o-', label='Team 0', color='blue', linewidth=2, markersize=8)\n",
            "    ax.plot(matches, team1_shots, 's-', label='Team 1', color='red', linewidth=2, markersize=8)\n",
            "    ax.set_xlabel('Match Number')\n",
            "    ax.set_ylabel('Shot Attempts')\n",
            "    ax.set_title('Shots on Goal per Match')\n",
            "    ax.legend()\n",
            "    ax.grid(True, alpha=0.3)\n",
            "    \n",
            "    # Possession percentage\n",
            "    ax = axes[1, 0]\n",
            "    team0_possession = [s['possession_pct'][0] for s in match_stats]\n",
            "    team1_possession = [s['possession_pct'][1] for s in match_stats]\n",
            "    \n",
            "    ax.bar(x - width/2, team0_possession, width, label='Team 0', color='blue', alpha=0.7)\n",
            "    ax.bar(x + width/2, team1_possession, width, label='Team 1', color='red', alpha=0.7)\n",
            "    ax.set_xlabel('Match Number')\n",
            "    ax.set_ylabel('Ball Possession (%)')\n",
            "    ax.set_title('Ball Possession Statistics')\n",
            "    ax.set_xticks(x)\n",
            "    ax.set_xticklabels(matches)\n",
            "    ax.legend()\n",
            "    ax.axhline(y=50, color='gray', linestyle='--', alpha=0.5)\n",
            "    ax.grid(True, alpha=0.3, axis='y')\n",
            "    \n",
            "    # Goal timeline (for first match)\n",
            "    ax = axes[1, 1]\n",
            "    if match_stats[0]['goals_timeline']:\n",
            "        goals = match_stats[0]['goals_timeline']\n",
            "        times = [g['time'] for g in goals]\n",
            "        teams = [g['team'] for g in goals]\n",
            "        colors = ['blue' if t == 0 else 'red' for t in teams]\n",
            "        \n",
            "        ax.scatter(times, teams, c=colors, s=200, alpha=0.7)\n",
            "        ax.set_xlabel('Time (seconds)')\n",
            "        ax.set_ylabel('Team')\n",
            "        ax.set_title('Goal Timeline (First Match)')\n",
            "        ax.set_yticks([0, 1])\n",
            "        ax.set_yticklabels(['Team 0', 'Team 1'])\n",
            "        ax.set_xlim(0, 20)\n",
            "        ax.grid(True, alpha=0.3)\n",
            "        \n",
            "        for i, (time, team) in enumerate(zip(times, teams)):\n",
            "            ax.annotate(f'{time:.1f}s', (time, team), \n",
            "                       xytext=(0, 10), textcoords='offset points',\n",
            "                       ha='center', fontsize=9)\n",
            "    else:\n",
            "        ax.text(0.5, 0.5, 'No goals scored', \n",
            "               ha='center', va='center', transform=ax.transAxes,\n",
            "               fontsize=14, color='gray')\n",
            "        ax.set_title('Goal Timeline (First Match)')\n",
            "    \n",
            "    plt.suptitle('20-Second Match Statistics', fontsize=16, fontweight='bold')\n",
            "    plt.tight_layout()\n",
            "    plt.show()\n",
            "\n",
            "print(\"\\n📈 Key Observations:\")\n",
            "print(\"  - 20秒の試合で戦略的な展開が可能\")\n",
            "print(\"  - 攻撃と防御の役割分担が明確\")\n",
            "print(\"  - ボール支配率と得点の相関\")"
        ]
    })
    
    # Create and display 20-second match video
    cells.append({
        "cell_type": "markdown",
        "metadata": {"id": "video_20sec_header"},
        "source": ["### 🎬 20秒マッチ動画"]
    })
    
    cells.append({
        "cell_type": "code",
        "metadata": {"id": "create_20sec_video"},
        "execution_count": None,
        "outputs": [],
        "source": [
            "# Create and display 20-second match video\n",
            "if match_videos and match_videos[0]:\n",
            "    print(\"🎬 Creating 20-second match video...\")\n",
            "    print(f\"   Frames: {len(match_videos[0])}\")\n",
            "    print(f\"   Duration: 20 seconds\")\n",
            "    print(f\"   FPS: 15 (downsampled from 30)\")\n",
            "    \n",
            "    video_path = '/tmp/soccer_20sec_match.mp4'\n",
            "    create_video_from_frames(match_videos[0], video_path, fps=15)  # 15 FPS for smaller file\n",
            "    \n",
            "    print(\"\\n✅ Video created successfully!\")\n",
            "    print(\"\\n📺 20-Second Soccer Match:\")\n",
            "    display(display_video(video_path))\n",
            "    \n",
            "    print(\"\\n🎯 視聴ポイント:\")\n",
            "    print(\"  - 20秒間の戦略的な攻防\")\n",
            "    print(\"  - アタッカーとディフェンダーの連携\")\n",
            "    print(\"  - スタミナによる後半の動きの変化\")\n",
            "    print(\"  - ゴールタイミングとチャンス創出\")\n",
            "else:\n",
            "    print(\"No video available. Please run the match first.\")"
        ]
    })
    
    return cells

# Create the extended notebook
if __name__ == "__main__":
    # Load the expert notebook
    with open("/home/user/webapp/multiagents_soccer_expert.ipynb", "r", encoding="utf-8") as f:
        notebook = json.load(f)
    
    # Add 20-second episode cells
    new_cells = create_longer_episode_cells()
    notebook['cells'].extend(new_cells)
    
    # Save as new notebook
    with open("/home/user/webapp/multiagents_soccer_20sec.ipynb", "w", encoding="utf-8") as f:
        json.dump(notebook, f, indent=2, ensure_ascii=False)
    
    print("✅ 20-second episode notebook created!")
    print("📁 Saved as: multiagents_soccer_20sec.ipynb")
    print("\n🎯 主な特徴:")
    print("  1. エピソード長: 20秒（600ステップ）")
    print("  2. 役割分担: アタッカー/ディフェンダー")
    print("  3. スタミナシステム: 長期戦での戦略性")
    print("  4. 詳細統計: ボール支配率、シュート数、ゴールタイムライン")
    print("  5. 高品質動画: 20秒の完全試合録画")